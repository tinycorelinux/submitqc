#!/bin/sh

###>>>
###>>>   Tiny Core Extension audit script - www.tinycorelinux.net
###>>>
###>>>   Copyright (C) 2015 The Core Project & Tiny Core Linux Team (www.tinycorelinux.net)
###>>>
###>>>   This program is free software; you can redistribute it and/or
###>>>   modify it under the terms of the GNU General Public License
###>>>   as published by the Free Software Foundation; either version 2
###>>>   of the License, or (at your option) any later version.
###>>>
###>>>   This program is distributed in the hope that it will be useful,
###>>>   but WITHOUT ANY WARRANTY; without even the implied warranty of
###>>>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
###>>>   GNU General Public License for more details.
###>>>
###>>>   You should have received a copy of the GNU General Public License
###>>>   along with this program; if not, write to the Free Software
###>>>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
###>>>

#<<
#<<  CHANGES
#<<
#<<  20101206 - original written and managed by JasonW
#<<  2010-20140210 - many updates made by coreplayer2 and gordonselfish
#<<  20150708 - various changes by dentonlt
#<<     query version/arch, comment code, use DEPLIST for ext loading by TC version,
#<<     move md5 check to subroutine; work from squashfs; check net connection;
#<<     added usage/help text, check dep file with base (not after), fix kernel grep pattern,
#<<     re-order checking/reporting routines
#<<  20150917 - fix grep (add -m1) in checkinfo(); kudos to gordon64 for the bug report
#<<  20150919 - fix/rewrite perms/user/grp checking on files & dirs;
#<<     add "--fix" option to force repair/change to file perms on scan
#<<     kudos to gordon64 for the bug report leading to these changes; dentonlt
#<<  20150920 - fix Title check to ensure TESTING stays when present; check that
#<<     binaries have been stripped; add --strip, add -c/--color; misc cleanup; dentonlt
#<<  20150921 - fixes to checkfileperms(); checkdiff as checklist; remove checkbasedir;
#<<     rewrite checkinfo; add rotdash for processes that may take awhile; fix list-making
#<<     code (drop opening .); add checkcopyright; add checkbuilddep; dentonlt
#<<  20151002 - remove code block in loadextensions, add dep file (thanks to coreplayer2 for
#<<     bug reports leading to these changes); add check for copyright files in full
#<<     extension tree (thanks coreplayer2 for this code); rm bin.list after checkstripping;
#<<     swap order of checkmaintainer and checkinfo for clarity; dentonlt
#<<  20151004 - fix checkfileperms() where chmod would fail; various typos fixed; adjust/ensure
#<<     skip network checks when appropriate; fix startup script/dir permissions (kudos
#<<     to coreplayer2 for the bug report here, too!); dentonlt
#<<  20151005 - adjust rotdash placement in checkfileperms; add extension checking to
#<<     checkdeps; dentonlt
#<<  20151007 - fix traps; create cleanonsignal(); adjust checkinfo to grep for
#<<     "Extension[-_]by"; dentonlt
#<<  20151010 - checkinfo(): use both coreutils du and busybox du for size check;
#<<     checkdeps(): check file structure (one dep per line); dentonlt
#<<  20151013 - add checklibs() for dynamic library checking; dentonlt
#<<  20151017 - move info/dep checks to before squashfs cks - dep ck req'd for
#<<     accurate checklibs(); add checkempty(); var checklibs fixes; add core/arch options
#<<     add changes & license options (GPLv2 was in Jason W's original info file); bugfix
#<<     cleanonsignal (was leaving squashfs dir); dentonlt
#<<  20160204 - updated version checking; juanito
#<<  20160316 - add armv7l to ARCH testing, fix ARCH assignment bug (kudos andyj);
#<<     change release text to 'unstable', request feedback on ARM; begin
#<<     selfpackage() for cross-repo submission/updates; dentonlt
#<<  20190218 - bugfix (Rich) at lines 657, 834 (juanito)
#<<  20201109 - add aarch64 by polikuo (juanito)
#<<  20230308 - ensure correct ownerships and permissions (gnuser)
#<<  20230309 - fix startup script permissions in one place only (gnuser)
#<<  20230310 - 775 perm on startup script (cosmetic, to match wiki recommendation), fix version string (gnuser)
#<<  20230318 - rebuild squashfs only if necessary (gnuser)
#<<  20230826 - versioning, add logs for better tracking, VERSIONSTRING test adjusted;
#<<     coding style, remove trailing white space, indention adjusted - no more tabs (polikuo)
#<<  20230827 - bugfix - tc:staff --> root:staff (polikuo)
#<<  20230828 - tune architecture detection, enable zsync for armv7 (polikuo)
#<<  20230831 - add function prepareinfo(), adjust everything accordingly. (polikuo)
#<<     rewrite checkfileperms() for speed
#<<     remove duplicate: checkbasicfileperms(), is a duplicate to checkfileperms()
#<<     review check list - STUFF TO DO
#<<        * Check that checkstartup applies changes BEFORE moving on to checkfileperms
#<<           checked
#<<        * if there is no startup file, but the current repository extension has one ... warn.
#<<           checked
#<<        * check for PPI compatibility [deprecated?]
#<<           checked, it's deprecated
#<<  20230907 - minor bug fix, default behavior for permission check: warn --> fix (polikuo)
#<<  20240118 - checkinfo needs to ensure "Tags:" field exists, added --no-load flag (gnuser)
#<<  20240212 - cleanup fix/don't fix logic (gnuser)
#<<  20240528 - add --blocksize flag (gnuser)
#<<  20240915 - broader recognition of executable text files (gnuser)
#<<  20241215 - check for redundant dependencies (extension families) and remove them (make a backup) (Sashank999)
#<<  20241218 - redundant dependency check reimplemented in awk (Sashank999)
#<<  20241219 - add zsync to required deps, check source.tgz file contents, fetch .info file from repo if not present locally (Sashank999)
#<<  20250118 - add -KERNEL substitution to library dependency checking, remove SUID bits from directories, add error log for /lib64 dependency linking (Sashank999)
#<<
#<<  STUFF TO DO
#<<
#<<  * if usr/local/share/applications/ is included, expect $F.desktop and icon
#<<  * if usr/local/share/pixmaps/ included, expect $F.png (icon file)
#<<  * checktgz should check the content and structure of the tgz file (should this be xz?)
#<<  * since this is a large script with many functions ...
#<<    consider splitting it into smaller scripts (eg tc-ext-perms, tc-ext-startup, etc)
#<<    that each check an area of settings and make adjustments as needed. Then use
#<<    submitqc to call on those other scripts (and refer user to other scripts
#<<    to check and fix individual issues/areas)
#<<

####################
# SETUP
####################

RUNDIR="$PWD"
SCRIPT=$(basename $0)
VERSIONSTRING="20241219"
[ $(echo "$VERSIONSTRING" | grep "$(date '+%Y%m%d')") ] && VERSIONSTRING="SOURCE RUN"

. /etc/init.d/tc-functions
COLOR=0

# handle cmdline args
for i in $*
do
  case $i in
    -c) COLOR=1 ;;
    --color) COLOR=1 ;;
    --kernel=*) KVER="${i#--kernel=}"; KERNELFORCE=1 ;;
    --core=*) TCVER="${i#--core=}" ;;
    --arch=*) ARCH="${i#--arch=}" ;;
    --nonet) INET="nonet" ;;
    --libs) LIBCHECK=1 ;;
    -?) USAGE=1 ;;
    -h) USAGE=1 ;;
    --help) USAGE=1 ;;
    --tcz=*) TCZLIST="$(basename ${i#--tcz=} .tcz).tcz" ;;
    --no-fix) NOFIX=1 ;;
    --strip) STRIP=1 ;;
    --self-package) PACKAGING=1 ;;
    --changes) cat $(which $0) | grep "^#<<" | sed 's/^#<<//' ; exit ;;
    --license) cat $(which $0) | grep "^###>>>" | sed 's/^###>>>//' ; exit ;;
    --no-load) NOLOAD=1 ;;
    --blocksize=*) BLOCKSIZE="${i#--blocksize=}" ;;
    *) # might be an extension filename/base
      [ -e $(basename ${i} .tcz).tcz ] && TCZLIST=$(basename ${i} .tcz).tcz
      ;;
  esac
done

# Reset color code variables unless --color is explicitly enabled.
# This is done in order to stay compatible with the old behaviour,
# which did not source /etc/init.d/tc-functions causing colors
# to just be ignored. Now it is sourced always, causing colored
# output as default behaviour.
if [ $COLOR = 0 ]; then
  CRE=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  MAGENTA=""
  CYAN=""
  WHITE=""
  NORMAL=""
fi


# set up list of extensions to check

if [ "$TCZLIST" ] && [ "$(dirname $TCZLIST)" != "." ]; then
  echo "Run $SCRIPT in the same directory as your extension(s)."
  exit 1
fi

[ -z "$TCZLIST" ] && TCZLIST="$(find -maxdepth 1 -name "*.tcz" | sed 's/^\.\///')"
[ -z "$KVER" ] && KVER="$(uname -r)"
[ -z "$TCVER" ] && TCVER="$(version | sed 's/\..*//')"
# [ -z "$TCVER_INT" ] && TCVER_INT="$(version | grep -o '^[0-9]*')"
[ -z "$BLOCKSIZE" ] && BLOCKSIZE=4096
TCVER=${TCVER%%.*}.x

# output usage

if [ ! "$PACKAGING" ]; then
  if [ ! "${TCZLIST}" ] || [ "$USAGE" ]; then
    echo ""
    echo "submitqc is the Tiny Core extension submission quality testing tool."
    echo "This unstable release ($VERSIONSTRING) is UNDER TESTING for TC5+, x86/x86_64/armv7."
    echo "In particular, feedback/testing on Pi/ARM usage is welcome!"
    echo ""
    echo "Usage: $SCRIPT [-?|-h|--help] [--kernel=KVER] [--nonet] [--no-fix] \
    [--tcz=TCZFILE] [TCZFILE] [--changes] [--license] [--no-load] [--blocksize=BLOCKSIZE]" | fmt -w 75 -u -t
    echo ""
    echo "Run $SCRIPT in the same directory as your extension(s). It will find & \
    test tcz files in the run directory." | fmt -w 75 -ut
    echo ""
    echo "Options:"
    echo ""
    echo -e "  -c --color\t\tUse colored text output"
    echo -e "  --kernel=KVER\t\tTest modules using KVER (default: \`uname -r\`)"
    echo -e "  --core=TCVER\t\tRefer to online repo for core TCVER (default: \`version\`)"
    echo -e "  --arch=ARCH\t\tRefer to online repo for architecture ARCH (default: \`uname -m\`)"
    echo -e "  --libs\t\tTry dynamic library inclusion tests (unstable; time-consuming)"
    echo -e "  --nonet\t\tDisable network-based checks"
    echo -e "  --no-fix\t\tDon't fix chmod/chown inconsistencies (default: fix)"
    echo -e "  --strip\t\tStrip any unstripped binaries (default: warn)"
    echo -e "  --changes\t\tView change and planning details"
    echo -e "  --self-package\tSelf-package under /tmp/${SCRIPT}-pkg/"
    echo -e "  --license\t\tView license details (GNU GPLv2)"
    echo -e "  --no-load\t\tDon't load any required extensions (coreutils, squashfs-tools, etc.)"
    echo -e "  --blocksize=BLOCKSIZE\tBlocksize in Bytes (default: 4096) (only for 64-bit)"
    echo ""
    echo "$SCRIPT is distributed under the terms of the GNU GPLv2. see --license."
    echo ""
    exit 0
  fi
fi

# library/dep checking variables
# [ -z "$ARCH" ] && ARCH=$(uname -m)
# safest way to set ARCH
[ -z "$ARCH" ] && ARCH=$(. /etc/init.d/tc-functions; getBuild)
RAND="$(date +%s | md5sum | head -c4)"
REPO=/etc/sysconfig/tcedir/optional
REQLOG=/tmp/$SCRIPT/$$-$RAND.req # libs req'd
INCLOG=/tmp/$SCRIPT/$$-$RAND.dep # libs in deps
REPOLOG=/tmp/$SCRIPT/$$-$RAND.repo # libs in repo missing from extension
MIRROR="$(cat /opt/tcemirror)"
unset LIBS
unset CHECKLIST

# prepare TEMPLIST - used during signal trap cleanup
TEMPLIST="$REQLOG $INCLOG $REPOLOG *.dep-mirror"

# this is used during checklibs() to ignore dependency on system libs
BASELIBS='ANSI_X3.110.so ISO8859-15.so ISO8859-1.so ISO8859-2.so ld-2.20.so ld-linux-aarch64.so.1 ld-linux-armhf.so.3 ld-linux.so.2 ld-linux-x86-64.so.2 libanl-2.20.so libanl.so libanl.so.1 libblkid.so libblkid.so.1 libblkid.so.1.1.0 libc-2.20.so libcom_err.so libcom_err.so.2 libcom_err.so.2.1 libcrypt-2.20.so libcrypt.so libcrypt.so.1 libc.so.6 libdl-2.20.so libdl.so libdl.so.2 libe2p.so libe2p.so.2 libe2p.so.2.3 libext2fs.so libext2fs.so.2 libext2fs.so.2.4 libgcc_s.so libgcc_s.so.1 libm-2.20.so libm.so libm.so.6 libnsl-2.20.so libnsl.so libnsl.so.1 libnss_compat-2.20.so libnss_compat.so libnss_compat.so.2 libnss_dns-2.20.so libnss_dns.so libnss_dns.so.2 libnss_files-2.20.so libnss_files.so libnss_files.so.2 libpthread-2.20.so libpthread.so.0 libresolv-2.20.so libresolv.so libresolv.so.2 librt-2.20.so librt.so librt.so.1 libstdc++.so libstdc++.so.6 libstdc++.so.6.0.20 libsudo_noexec.so libsysfs.so libsysfs.so.2 libsysfs.so.2.0.1 libutil-2.20.so libutil.so libutil.so.1 libuuid.so libuuid.so.1 libuuid.so.1.3.0 libz.so libz.so.1 libz.so.1.2.8 linux-gate.so.1 linux-vdso.so.1 sudo_noexec.so UNICODE.so'

# case "$ARCH" in
#   i686) ARCH="x86" ;;
#   x86_64) [ -f /lib/ld-linux-x86-64.so.2 ] || ARCH="x86" ;;
#   armv6*) ARCH="armv6";;
#   armv7*)
#     # Use raspi cpu revision to detect board
#     # REV 1=BCM2836, 2=BCM2837, 3=BCM2711
#     REV=$(cat /proc/cpuinfo | awk '/Revision/ {print $3}')
#     REV=${REV:-6}
#     case ${REV:2:1} in
#       1|2) ARCH="armv7";;
#       3) ARCH="armv7l";;
#       *) echo "$SCRIPT: Unrecognized armv7 architecture. See --help." && exit 1 ;;
#     esac
#     ;;
#   aarch64) ARCH="aarch64";;
#   *) echo "$SCRIPT: Unrecognized architecture '$ARCH'. See --help." && exit 1 ;;
# esac

for KNOWN_ARCH in x86 x86_64 armv6 armv7 armv7l armhf aarch64; do
  [ $ARCH = $KNOWN_ARCH ] && FOUND_KNOWN_ARCH=1
done
if [ -z "$FOUND_KNOWN_ARCH" ]; then
  echo "$SCRIPT: Unrecognized architecture '$ARCH'. See --help."
  exit 1
fi

# other global variables
REPO_URL="$(cat /opt/tcemirror)$TCVER/$ARCH/tcz"
FILE_INFO=$(mktemp -t submitqc.file.XXXXXX) # a temporary file to hold output from the "file" command
FILE_PERM=$(mktemp -t submitqc.perm.XXXXXX) # a temporary file to hold output from the "ls" command
AWK_CACHE=$(mktemp -t submitqc.cache.XXXXXX) # a temporary file for "awk" to hold stuff
CHANGES= # when script makes changes to extension, remember to rebuild

####################
####################
# SUPPORT FXNS
####################
####################

# clean up on failed run
cleanonsignal() {

  # remove traps, in case this function fails
  trap - SIGHUP SIGINT SIGQUIT SIGTERM SIGSTOP SIGABRT

  echo
  echo -e "\tCaught interrupt."
  echo -en "\tKilling subprocesses ... "
  sudo pkill -P $$ # kill any subprocesses (children of this process)
  wait $$
  echo "Ok."

  echo -en "\tCleaning up temp files ... "
  rm -f $FILE_INFO $FILE_PERM
  [ "$TEMPLIST" ] && \
  for E in $TEMPLIST; do
    if [ -e /tmp/submitqc/$E ]; then
      sudo rm -rf $E || echo -en "\n\tUnknown error removing /tmp/submitqc/$E"
    elif [ -e $RUNDIR/$E ]; then
      sudo rm -rf $RUNDIR/$E || echo -en "\n\tUnknown error removing $RUNDIR/$E"
    fi
  done
  echo "Ok."

  echo -e "\tLogs at /tmp/$SCRIPT will be removed on next run."
  echo -e "\tExiting early."
  exit 1

}

# announce script
announce() {
  echo ""
  echo "=============================================================="
  echo "This is the Tiny Core extension submission quality testing tool."
  # echo "This pre-release is UNDER TESTING for TC5/6 and x86/x86_64."
  echo ""
  echo "see --help for usage instructions."
  echo ""
  echo "Release: $VERSIONSTRING"
  echo "=============================================================="
  echo ""
  echo "${GREEN}Checking against Core release $TCVER on $ARCH / $KVER ${NORMAL}"
  echo ""
}

# self-packaging - cool!
selfpackage() {

  # if [ "$TCVER_INT" -gt 5 ]; then
    tce-load -i squashfs-tools
    [ $? != 0 ] && echo "Need squashfs-tools!" && exit 1
  # else
  #   tce-load -i squashfs-tools-4.x
  #   [ $? != 0 ] && echo "Need squashfs-tools-4.x!" && exit 1
  # fi

  # if [ "${ARCH}" != "armv7" ]; then
    tce-load -i zsync
    [ $? != 0 ] && echo "Need zsync!" && exit 1
  # fi

  # package this script for each repo ...
  mkdir -p /tmp/${SCRIPT}-pkg

  # get info file ... =)
  if [ ! -e ${SCRIPT}.info ]; then
    wget $(cat /opt/tcemirror)7.x/x86_64/tcz/${SCRIPT}.tcz.info
    [ $? != 0 ] && echo "$SCRIPT: error fetching .info file - can't package!" && return 1
  else
    cp -f $SCRIPT.info /tmp/${SCRIPT}-pkg/$SCRIPT.tcz.info
  fi

  echo "Changes must be manually entered into the script itself. Info file editing, however,"
  echo "is automated here."
  read -p "Text for 'Current:' line in info file (enter single space for no change to info file): " APPEND

  for CPU in armv7 x86 x86_64; do
  for VER in 5 6 7; do

    # no armv7 5.x repo
    set -x
    [ "$VER" -lt 6 ] && [ "$CPU" = "armv7" ] && continue
    set +x

    # clean out old packages ...
    rm -rf /tmp/${SCRIPT}/$CPU/$VER
    rm -rf /tmp/${SCRIPT}-pkg/$CPU/$VER

    # place script
    mkdir -p /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/bin/
    cp -f ${0} /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/bin/
    sudo chown root:root /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/bin/${SCRIPT}
    sudo chmod 755 /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/bin/${SCRIPT}

    # place copyright text
    mkdir -p /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/share/doc/${SCRIPT}
    cat ${0} | grep "###>>>" | sed 's/^###>>>//' > \
      /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/share/doc/${SCRIPT}/COPYING
    sudo chown root:root /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/share/doc/${SCRIPT}/COPYING
    sudo chmod 644 /tmp/${SCRIPT}/$CPU/$VER/root/usr/local/share/doc/${SCRIPT}/COPYING

    #set dir perms ...
    find /tmp/${SCRIPT}/$CPU/$VER/root -type d \
       -exec sudo chown root:root {} \;
    find /tmp/${SCRIPT}/$CPU/$VER/root -type d \
       -exec sudo chmod 755 {} \;

    # create DEP file ...
    DEPLIST="file diffutils wget coreutils grep binutils"
    if [ "$VER" -gt "5" ]; then
      DEPLIST="$DEPLIST squashfs-tools"
    else
      DEPLIST="$DEPLIST squashfs-tools-4.x"
    fi

    if [ "$CPU" != "arm" ]; then
      DEPLIST="$DEPLIST zsync"
    fi

    for F in $DEPLIST; do
      echo "$F.tcz" >> /tmp/submitqc/$CPU/$VER/submitqc.tcz.dep
    done

    # make squashfs
    mksquashfs /tmp/${SCRIPT}/$CPU/$VER/root /tmp/${SCRIPT}/$CPU/$VER/submitqc.tcz -b "$BLOCKSIZE"

    # make file list
    cd /tmp/${SCRIPT}/$CPU/$VER/root/
    find -not -type d > ../${SCRIPT}.tcz.list
    sed -i 's/^\.//' ../${SCRIPT}.tcz.list # drop opening '.'
    cd -

    # remove installation tree
    sudo rm -rf /tmp/${SCRIPT}/$CPU/$VER/root

    # make md5sum ...
    cd /tmp/${SCRIPT}/$CPU/$VER
    md5sum ${SCRIPT}.tcz > /tmp/${SCRIPT}/$CPU/$VER/${SCRIPT}.tcz.md5.txt
    cd -

    # if [ "$ARCH" != "armv7" ]; then
      # make zsync
      cd /tmp/${SCRIPT}/$CPU/$VER
      zsyncmake -u ${SCRIPT}.tcz ${SCRIPT}.tcz
      cd -
    # fi

    if [ "$APPEND" ] && [ ! "$APPEND" = " " ]; then
      # append updated change details to info file ...
      grep -v "Current:" ${SCRIPT}.tcz.info > \
        /tmp/${SCRIPT}/$CPU/$VER/${SCRIPT}.tcz.info
      echo -e "\t\t\t\t$(grep "Current:" $SCRIPT.tcz.info | \
        sed 's/^Current:[ \t]*//')" >> \
        /tmp/${SCRIPT}/$CPU/$VER/$SCRIPT.tcz.info

      echo -e "\nCurrent:\t\t$(date +%Y/%m/%d) $APPEND" >> \
        /tmp/${SCRIPT}/$CPU/$VER/$SCRIPT.tcz.info
    else
      cp /tmp/${SCRIPT}-pkg/${SCRIPT}.tcz.info /tmp/${SCRIPT}/$CPU/$VER/
    fi

    # create tar ...
    cd /tmp/$SCRIPT/$CPU/$VER/
    tar -czf ${SCRIPT}.tar.gz *
    cd -

  done # per TC repo
  mv /tmp/$SCRIPT/$CPU /tmp/${SCRIPT}-pkg/
  done # per arch

  rm /tmp/${SCRIPT}-pkg/${SCRIPT}.tcz.info

  echo
  echo "${SCRIPT}: Ok! See /tmp/${SCRIPT}-pkg subdirectories for individual extensions."
  return 0

}

# load extensions
loadextensions() {

  echo -n "${BLUE}$SCRIPT: loading required extensions ... ${NORMAL}"

  # load dependencies
  # if [ "$TCVER_INT" -gt "5" ]; then
  #   DEPLIST="file diffutils squashfs-tools wget coreutils grep"
  # else
  #   DEPLIST="file diffutils squashfs-tools-4.x wget coreutils grep"
  # fi

  # TC is removing the 4.x release, do we still need this checker ?
  DEPLIST="file diffutils squashfs-tools wget coreutils grep zsync"

  # not available on arm at 20160316
  # totally fine now 20230828
  # [ ! "$ARCH" = "armv7" ] && DEPLIST="$DEPLIST zsync binutils"

  for FILE in $DEPLIST; do
    if [ ! -e "/usr/local/tce.installed/$FILE" ]; then
      tce-load -i $FILE
      [ $? != 0 ] && echo "${RED}$SCRIPT: Error in tce-load. Halting ${NORMAL}" && exit 1
    fi
  done
  echo "${GREEN}Done.${NORMAL}"

}

# remove/clear old log files ...
cleanuplogs() {

  echo -n "${BLUE}$SCRIPT: removing old log files. ${NORMAL}"
  rm -rf /tmp/submitqc

  echo "${GREEN}Ok.${NORMAL}"

  echo -n "${BLUE}$SCRIPT: making space for new log files. ${NORMAL}"
  mkdir -p /tmp/submitqc/missingdeps

  echo "${GREEN}Done.${NORMAL}"

}

# check that network connection (mirror) is up
checknetwork() {

  # test for network connection - needed for for checking against repository ...
  if [ "$INET" = "nonet" ]; then
    echo -n "${YELLOW}$SCRIPT: '--nonet': networking disabled on command line. ${NORMAL}"
    INET=
    return
  fi

  INFO_LST_URL=${REPO_URL}/info.lst.gz
  DEP_DB_URL=${REPO_URL}/dep.db.gz

  OLDLIST="$TEMPLIST"
  TEMPLIST="$TEMPLIST cnxn.test"
  (
    echo -n "${BLUE}$SCRIPT: checking $(cat /opt/tcemirror) (timeout 3 sec) ... ${NORMAL}"
    wget --spider -q --timeout=3 ${INFO_LST_URL} 2>&1 > /dev/null
    if [ $? = 0 ]; then echo "exists" > /tmp/submitqc/cnxn.test
    else echo "down" > /tmp/submitqc/cnxn.test
    fi
  ) &
  rotdash $!

  [ -e "/tmp/submitqc/cnxn.test" ] && \
    [ -n "$(grep "exists" /tmp/submitqc/cnxn.test)" ] && INET=1
  rm -f /tmp/submitqc/cnxn.test
  TEMPLIST="$OLDLIST"

  # download list of available extensions
  if [ $INET ]; then
    echo "${GREEN}Connected!${NORMAL}"
    {
    echo -n "${BLUE}$SCRIPT: fetching info.lst.gz and dep.db.gz ... ${NORMAL}"

    wget -q -O /tmp/submitqc/.info.lst.gz ${INFO_LST_URL} &&\
    gunzip /tmp/submitqc/.info.lst.gz && \
    sed -i 's:.tcz::g' /tmp/submitqc/.info.lst

    wget -q -O /tmp/submitqc/.dep.db.gz ${DEP_DB_URL} &&\
    gunzip /tmp/submitqc/.dep.db.gz
    } || {
    echo -e "\n${YELLOW}Error in fetch - some tests will be skipped.${NORMAL}"
    INET=
    }
    echo "${GREEN}Ok.${NORMAL}"
  else
    echo -e "\n\t${YELLOW}Connection or mirror down - some tests will be skipped.${NORMAL}"
  fi

}

# check that the extension mounts alright
checkmount() {

  echo -n "${BLUE}$SCRIPT: ${F} mountable? ${NORMAL}"

  # if SQUASHDIR it just happens to already exist ... get rid of it
  df | grep "$SQUASHDIR" > /dev/null 2>&1 && sudo umount "$SQUASHDIR"
  rm -rf /tmp/submitqc/"$SQUASHDIR"

  # if file is not a squashfs ... skip it.
  if [ "$(file ${F} | grep 'Squashfs' | cut -f1 -d':')" != "$F" ]; then
    echo "${RED} Not a valid tcz - not squashfs. Remake.${NORMAL}"
    echo $F >> /tmp/submitqc/corrupttcz
    return 1
  fi

  # try to mount
  (
  mkdir -p "${SQUASHDIR}"
  sudo mount -o loop ${F} ${SQUASHDIR} 2>&1 > /dev/null
  if [ $? != 0 ]; then
    echo "${RED}Error mounting - remake.${NORMAL}"
    echo "$F" >> /tmp/submitqc/corrupttcz
    return 1
  fi

  # umount
  sudo umount -d "$SQUASHDIR"
  sleep 2
  rm -rf "$SQUASHDIR"
  ) &
  rotdash $!

  echo "${GREEN}Passed mount check.${NORMAL}"

  return 0
}

# check that blocksize is what user expects (4096 B is default)
checkblock() {

  echo -n "${BLUE}$SCRIPT: ${F} correct block size? ${NORMAL}"

  if ! unsquashfs -s "$F" | grep "Block size" | grep "$BLOCKSIZE" > /dev/null; then
    echo "${YELLOW}Not in $BLOCKSIZE block size. Extension will be rebuilt.${NORMAL}"
    CHANGES=1
  else
    echo "${GREEN}Yes.${NORMAL}"
  fi

} # end checkblock()

# check that squashfs has something in it
checkempty() {

  echo -n "${BLUE}$SCRIPT: ${F} squashfs tree has files in it? ${NORMAL}"

  if [ "$(unsquashfs -ls $F | grep squashfs-root | wc -l)" = "1" ]; then
    echo -e "\n\t${RED}It appears $F is empty! Remake.${NORMAL}"
    echo "$F" >> /tmp/submitqc/emptysquashfs
    return 1
  fi

  echo "${GREEN}Ok.${NORMAL}"
  return 0

}

# check for excess (or missing) file trees inside of squashfs
checkappend() {

  echo -n "${BLUE}$SCRIPT: ${F} squashfs tree ok? ${NORMAL}"

  if [ "$(find -maxdepth 1 -name 'usr_')" ]; then
    echo "${RED} It appears $F contains more than one squashfs tree. Remake.${NORMAL}"
    echo "$F" >> /tmp/submitqc/appendeddata
    return 1
  fi

  echo "${GREEN}Ok.${NORMAL}"
  return 0

} # end checkappend()

# if ext has a startup file, check startup name, permissions, location, etc.
checkstartup() {

  echo -n "${BLUE}${SCRIPT}: ${F} startup files ok? ${NORMAL}"

  local DIRERROR SSDIR SS
  if ! grep -q 'usr/local/tce.installed' $FILE_PERM; then
    echo "${GREEN}None present. Ok, I think.${NORMAL}"
    return # no startup script
  fi

  # count files in startup script dir; get name of startup script
  SSDIR="usr/local/tce.installed/"
  # SS="$(ls -A $SSDIR)"
  # COUNT="$(echo "$SS" | wc -l)"
  COUNT=$(grep $SSDIR $FILE_PERM | wc -l)

  # startup script is a file, not directory
  if grep $SSDIR $FILE_PERM | grep -q '^d'; then
    echo "${RED}${F}: directories found. Repair manually.${NORMAL}"
    grep $SSDIR $FILE_PERM | grep '^d'
    echo "${F}: directories found. Repair manually." >> /tmp/submitqc/startupscript
  fi

  # is there only 1 startup file, named same as extension?
  case $COUNT in
    0)  echo -e "${RED}Has startup folder but no script. Repair manually.${NORMAL}"
        echo -e "${F}: startup folder without script. Repair manually." \
        >> /tmp/submitqc/startupscript
        ;;
    1)  SS=$(grep $SSDIR $FILE_PERM)
        SS=${SS##*/}
        if [ "${SS}" != "${BASENAME}" ]; then
          echo -ne "\n${YELLOW}script name ($SS) is incorrect. Renaming ${BASENAME}. ${NORMAL}"
          echo "$F startup named $SS renamed $BASENAME" >> /tmp/submitqc/wrongstartscriptname
          # SS="$(find $SSDIR -not -type d | tail -n 1)"
          # mv "${SS}" "${SSDIR}${BASENAME}"
          mv "./usr/local/tce.installed/${SS}" "./usr/local/tce.installed/${BASENAME}"
          echo "${YELLOW}Done.${NORMAL}"
          CHANGES=1
        fi
        ;;
    *)  echo -e "${RED}Multiple startup files, none named $F. Repair manually.${NORMAL}"
        echo -e "${F}: multiple startup files, none named $F. Repair manually." \
        >> /tmp/submitqc/startupscript
        ;;
  esac

  DIRERROR=

  if [ ! "$(stat -c%a ${SSDIR})" = 775 ]; then
    sudo chmod 775 "usr/local/tce.installed"
    echo -ne "\n\t${YELLOW}Startup directory permissions were corrected.${NORMAL}"
    DIRERROR=1
  fi

  if [ "$(stat -c'%U %G' ${SSDIR})" != "root staff" ]; then
    sudo chown root:staff "${SSDIR}"
    echo -ne "\n\t${YELLOW}Startup directory ownership was corrected.${NORMAL}"
    DIRERROR=1
  fi

  if [ ! "$(stat -c%a ${SSDIR}/$BASENAME)" = 775 ]; then
    sudo chmod 775 "${SSDIR}/$BASENAME"
    echo -ne "\n\t${YELLOW}Startup script permissions were corrected.${NORMAL}"
    DIRERROR=1
  fi

  if [ ! "$(stat -c'%U %G' ${SSDIR}/$BASENAME)" = "root staff" ]; then
    sudo chown root:staff "${SSDIR}/$BASENAME"
    echo -ne "\n\t${YELLOW}Startup script ownership was corrected.${NORMAL}"
    DIRERROR=1
  fi

  if [ $DIRERROR ]; then
    echo "$F" >> /tmp/submitqc/wrongstartscriptperms
    CHANGES=1
    echo
  else
    echo "${GREEN}Ok.${NORMAL}"
  fi

} # end checkstartup()

# look for COPYING or other text file at usr/local/share/doc/$BASENAME
checkcopyright() {

  echo -n "${BLUE}$SCRIPT: $F includes copyright notice? ${NORMAL}"
  E=${BASENAME##*-}

  [ ${E} = "doc" ] || [ ${E} = "locale" ] || [ ${E} = "dev" ] && \
    echo "${GREEN}Not needed for -${F##*-}. Done.${NORMAL}" && return

  COPYRIGHTFILES="/tmp/submitqc/$F.copyrightfiles"

  # look for copyright dir + files. If missing, no good.
  if [ ! -e "usr/local/share/doc/$BASENAME" ] \
    || [ "$(find usr/local/share/doc/$BASENAME -type f | wc -l)" = 0 ]; then
    MISSING=1
  fi

  if [ "$MISSING" ]; then
    echo -e "\n\t${YELLOW}Copyright notice not found at usr/local/share/doc/$BASENAME${NORMAL}"
    echo -e "\t${YELLOW}Confirm that this is not needed.${NORMAL}"

    # courtesy: look for copyright info in tree (kudos coreplayer2 for this)
    # LICENSEFILES="license copying copyright"
    # for c in ${LICENSEFILES}; do
    #   find . -type f -iname "${c}*" >> $COPYRIGHTFILES
    # done
    # (polikuo) don't use "for loop"
    grep -i 'license\|copying\|copyright' $FILE_INFO | cut -d ' ' -f 4 >> $COPYRIGHTFILES

    # remove any blank lines from COPYRIGHTFILES list
    sed -i '/^$/d' $COPYRIGHTFILES

    if [ "$(cat $COPYRIGHTFILES | wc -l)" != 0 ]; then
      echo -e "\n\t${YELLOW}Possible copyright files found:${NORMAL}"
      echo -e "${YELLOW}$(cat $COPYRIGHTFILES | sed 's/^/\t\t/g')${NORMAL}"
    else
      rm $COPYRIGHTFILES
    fi
    unset FOUND

    if [ $INET ]; then
      # courtesy: check if it's in the repo copy ...
      echo -e "\t${YELLOW}Checking repo for copyright statement in $F ...${NORMAL}"
      REPOLIST="/tmp/submitqc/${F}.repolist"
      wget -O ${REPOLIST} "$REPO_URL"/"$F".list > /dev/null 2>&1
      if [ $? = 0 ]; then
        if [ "$(grep "usr/local/share/doc/$BASENAME" $REPOLIST)" ]; then
          REMOTECOPYRIGHT=1
          echo -e "\t${RED}Repository copy of $F includes a copyright statement.${NORMAL}"
        else
          echo -e "\t${GREEN}Repo copy of $F does NOT include copyright statement.${NORMAL}"
        fi
      else
        echo -e "\t${YELLOW}$F not found on server.${NORMAL}"
      fi
    fi

    echo "$F: copyright information not found at usr/local/share/doc/$BASENAME/" >> \
    /tmp/submitqc/copyright
    [ $REMOTECCOPYRIGHT ] && echo -e "\tRepository copy includes a copyright statement." >> \
    /tmp/submitqc/copyright

  else
    echo -e "${GREEN}Looks ok.${NORMAL}"
  fi

  unset MISSING
  unset REMOTECOPYRIGHT

} # end checkcopyright

# check permissions of all files/directories
checkfileperms() {
  # define the scope of these variables
  local D_RR D_755 F_RR F_755 F_644 P_OUT

  echo -n "${BLUE}$SCRIPT: $F file/directory ownerships & permissions ok? ${NORMAL}"

  LOG="/tmp/submitqc/fileperms"

  # the startup directory was tested in checkstartup(). Ignore it at this point.

  # Find directories without root:root and/or 755. Skip tce.installed.
  # Test all files. root:root. executables 755, others 644. Skip tce.installed.

  # D_RR, F_RR, D_755, F_755, F_644
  awk '!/tce.installed/' $FILE_PERM > $AWK_CACHE
  D_RR=$(awk '/^d/ && $2 $3 != "root" "root" {print $NF}' $AWK_CACHE)
  F_RR=$(awk '/^[^d]/ && $2 $3 != "root" "root" {print $NF}' $AWK_CACHE)
  D_755=$(awk '/^d/ && !/^drwxr-xr-x/ {print $NF}' $AWK_CACHE)
  # The filenames may disrupt with the pattern matching if you simply use /executable/
  # For instance, if a file is call "README-about-executable.txt"
  # It would go into F_644, which is unwanted behavior
  awk '/^[^d]/ && !/^-rwxr-xr-x/ && !/tce.installed/ {print $NF}' $FILE_PERM > $AWK_CACHE
  F_755=$(awk -v FS=": " -v cache="$AWK_CACHE" 'BEGIN{while(getline buff < cache)P[buff]=1}
  P[$1] && (/: .*executable/ || /: .*script/ || /: .*shared object/) {print $1}' $FILE_INFO)
  awk '/^[^d]/ && !/^-rw-r--r--/ && !/tce.installed/ {print $NF}' $FILE_PERM > $AWK_CACHE
  F_644=$(awk -v FS=": " -v cache="$AWK_CACHE" 'BEGIN{while(getline buff < cache)P[buff]=1}
  P[$1] && !/: .*executable/ && !/: .*script/ && !/: .*shared object/ && !/: .*symbolic link/ {print $1}' $FILE_INFO)

  if [ "${D_RR}${F_RR}${D_755}${F_755}${F_644}" ]; then
    # if anything
    printf "\n\n"
    # may contain current directory ".", remove "./" first
    # output format should be "usr/local/bin/binary"
    # root:root
    if [ "${D_RR}${F_RR}" ]; then
      P_OUT=$(echo "${D_RR}${F_RR}" | sort -u)
      P_OUT=$(echo "$P_OUT" | sed -e '/^[[:blank:]]*$/d' -e 's_^\./__' -e 's_^_\t\t_')
      echo -e "\t${YELLOW}Expected root:root ownership:\n${P_OUT}${NORMAL}\n"
    fi
    # 755
    if [ "${F_755}${D_755}" ]; then
      P_OUT=$(echo "${F_755}${D_755}" | sort -u)
      P_OUT=$(echo "$P_OUT" | sed -e '/^[[:blank:]]*$/d' -e 's_^\./__' -e 's_^_\t\t_')
      echo -e "\t${YELLOW}Expected 755 permission:\n${P_OUT}${NORMAL}\n"
    fi
    # 644
    if [ "$F_644" ]; then
      P_OUT=$(echo "$F_644" | sort -u | sed -e 's_^\./__' -e 's_^_\t\t_')
      echo -e "\t${YELLOW}Expected 644 permission:\n${P_OUT}${NORMAL}\n"
    fi
    # logging
    echo "${F}: Some directory or file permissions were incorrect or non-standard." >> $LOG
    [ "$D_RR" ] && echo -e "Directories - Expected root:root:\n${D_RR}\n">> $LOG
    [ "$D_755" ] && echo -e "Directories - Expected 755:\n${D_755}\n" >> $LOG
    [ "$F_RR" ] && echo -e "Files - Expected root:root:\n${F_RR}\n">> $LOG
    [ "$F_755" ] && echo -e "Files - Expected 755:\n${F_755}\n" >> $LOG
    [ "$F_644" ] && echo -e "Files - Expected 644:\n${F_644}\n" >> $LOG
    # Fixing
    if [ -z "$NOFIX" ]; then
      # fix permission/ownership errors
      echo -e "\t${YELLOW}fixing inconsistencies ... ${NORMAL}"

      if [ "${D_RR}${F_RR}" ]; then
        echo -e "\t${YELLOW}chown root:root files and directories${NORMAL}"
        # sudo chown root:root $D_RR $F_RR
        # use '-h' so it affects the links
        # guard the command length with awk
        echo -e "${D_RR}\n${F_RR}" | sudo awk 'BEGIN{E=0}{
          if(length(buff " " $0) > 130000) {
            e=system("chown -h root:root" buff)
            E = E || e
            buff = ""
          }
          buff = buff " " $0
        } END {
          if(buff) {
            e=system("chown -h root:root" buff)
            E = E || e
          }
          exit E
        }'
        [ $? != 0 ] && echo -e "\n${RED}Error in chown - halting.${NORMAL}" && exit 1
      fi

      if [ "${F_755}${D_755}" ]; then
        echo -e "\t${YELLOW}chmod 755 executable files and directories${NORMAL}"
        # MODETMP=/tmp/submitqc/mode-sample-$(date +%s | head -c4)
        # touch $MODETMP # using just chmod 755 doesn't adjust sticky bit
        # sudo chmod 755 $MODETMP
        # sudo chmod --reference=$MODETMP $D_755 $F_755
        # rm -f $MODETMP
        # just use 'chmod 0755'
        # Using 'chmod 00755' so that sticky bit for directories is also removed.
        echo -e "${F_755}\n${D_755}" | sudo awk 'BEGIN{E=0}{
          if(length(buff " " $0) > 130000) {
            e=system("chmod 00755" buff)
            E = E || e
            buff = ""
          }
          buff = buff " " $0
        } END {
          if(buff) {
            e=system("chmod 00755" buff)
            E = E || e
          }
          exit E
        }'
        [ $? != 0 ] && echo -e "\n${RED}Error in chmod - halting.${NORMAL}" && exit 1
      fi

      if [ "$F_644" ]; then
        echo -e "\t${YELLOW}chmod 644 normal files${NORMAL}"
        # sudo chmod 644 $F_644
        echo "$F_644" | sudo awk 'BEGIN{E=0}{
          if(length(buff " " $0) > 130000) {
            e=system("chmod 00644" buff)
            E = E || e
            buff = ""
          }
          buff = buff " " $0
        } END {
          if(buff) {
            e=system("chmod 00644" buff)
            E = E || e
          }
          exit E
        }'
        [ $? != 0 ] && echo -e "\n${RED}Error in chmod - halting.${NORMAL}" && exit 1
      fi

      echo "${F}: These errors were corrected." >> $LOG
      touch /tmp/submitqc/changes # rebuild tcz
      echo -e "${GREEN}Ok.${NORMAL}"
    else
      echo -e "\t${RED}You have warnings. See /tmp/submitqc/fileperms.${NORMAL}"
      echo -e "${RED}\tTo set defaults, omit the --no-fix flag.${NORMAL}"
      # log it:
      echo "To set defaults, omit the --no-fix flag." >> $LOG
    fi
  else
    echo -e "${GREEN}Ok.${NORMAL}"
  fi

  [ -e /tmp/submitqc/changes ] && CHANGES=1 && rm /tmp/submitqc/changes

}

# Warn elfs linked to /lib64/
checklib64() {
  echo -n "${BLUE}$SCRIPT: $F has any /lib64 dependencies?${NORMAL}"

  FOUND=false
  for file in $(find . -type f); do
    if ldd "$file" 2>/dev/null | grep -q "/lib64/"; then
      if ! $FOUND; then
        echo "${YELLOW}The following ELFs are linked to /lib64.${NORMAL}"
        echo "The following ELFs are linked to /lib64." >> /tmp/submitqc/lib64linkerrors
        FOUND=true
      fi
      echo "${YELLOW}$file is linked to /lib64.${NORMAL}"
      echo "$file is linked to /lib64." >> /tmp/submitqc/lib64linkerrors
    fi
  done

  if $FOUND; then
    echo "${RED}Compiled ELFs are linked to /lib64.${NORMAL}"
    echo "${RED}Please link to /lib or /usr/local/lib directories instead.${NORMAL}"
    echo "Compiled ELFs are linked to /lib64." >> /tmp/submitqc/lib64linkerrors
    echo "Please link to /lib or /usr/local/lib directories instead." >> /tmp/submitqc/lib64linkerrors
  else
    echo "${GREEN} None.${NORMAL}"
  fi
}

# check binaries have been stripped
checkstripping() {

  echo -n "${BLUE}$SCRIPT: $F binaries have been stripped? ${NORMAL}"

  # get a list of all un-stripped binaries.
  # unlikely, but filenames may contain colons ":"
  # for compilers, gcc or clang, some object files should not be stripped.
  BIN=$(grep 'not stripped' $FILE_INFO | grep -v 'relocatable' | sed 's_: .*__g')

  # (
  #   find -type f -exec file {} \; | grep 'not stripped' | cut -f1 -d: | sort | uniq \
  #   > /tmp/submitqc/bin.list
  # ) &
  # rotdash $!
  # BIN="$(cat /tmp/submitqc/bin.list)"


  if [ "$BIN" ]; then
    echo -e "\n\t${YELLOW}Some binaries have not been stripped:${NORMAL}"
    echo "${YELLOW}$BIN${NORMAL}" | sed "s_\./_\t_" | sed "2!s_^_\t_"

    if [ "$STRIP" ]; then
      echo -en "\t${YELLOW}Fixing ... ${NORMAL}"
      sudo strip --strip-all ${BIN} # need sudo due to root:root ownership
      [ $? != 0 ] && echo -e "\n${RED}Error in strip. Halting.${NORMAL}" && exit 1
      echo -e "${YELLOW}Done.${NORMAL}"
      # log the fixes
      echo "Some unstripped binaries were stripped:" >> /tmp/submitqc/stripping
      echo "$BIN" >> /tmp/submitqc/stripping
      CHANGES=1 # rebuild tcz
    else
      echo -e "\t${YELLOW}This may be intentional. Else to strip, use --strip.${NORMAL}"

      # log the file list
      echo "$F: Some binaries are not stripped:" >> /tmp/submitqc/stripping
      echo "$BIN" | sed "s/^/\t/g" >> /tmp/submitqc/stripping

      echo -e "\t${RED}You have warnings.${NORMAL}"
    fi
  else
    echo "${GREEN}Ok.${NORMAL}"
  fi

  # rm /tmp/submitqc/bin.list
  unset BIN

}

# check maintainer=submitter, look for extensions with similar names
checkmaintainer() {

  if [ ! $INET ]; then
    echo -e "${YELLOW}${SCRIPT}: $F Network/mirror down. Skipping repo .info file comparison.${NORMAL}"
    return
  fi

  echo -n "${BLUE}$SCRIPT: $F info similar to others in repository? ${NORMAL}"

  # if extension is in repository, check submitter = maintainer, warn if not same
  wget -O /tmp/submitqc/.${F}.info "${REPO_URL}/${F}.info" > /dev/null 2>&1
  if [ $? = 0 ]; then
    MAINTAINER="$(grep -G "Extension.by" /tmp/submitqc/.${F}.info | awk '{print $2}')"
    [ -e ${F}.info ] && SUBMITTER="$(grep -G "Extension.by" "$F".info | awk '{print $2}')"
    if [ "${MAINTAINER}" != "${SUBMITTER}" ]; then
    echo -e "\n\t${YELLOW}Ensure current/past maintainer ${MAINTAINER} knows you are updating ${F}.${NORMAL}"
    echo "Extension: $F" >> /tmp/submitqc/tcemaintainer
    echo "Maintainer: $MAINTAINER" >> /tmp/submitqc/tcemaintainer
    echo "Submitter: $SUBMITTER" >> /tmp/submitqc/tcemaintainer
    echo "---" >> /tmp/submitqc/tcemaintainer
    fi
  fi

  rm -f /tmp/submitqc/.${F}.info

  # look for similarly named extensions, warn user
  SIMILAR="$(grep -e $BASENAME /tmp/submitqc/.info.lst)"

  if [ -n "$SIMILAR" ]; then
    echo "$F: similarly named extensions:" >> /tmp/submitqc/similarextensions
    echo "$SIMILAR" | sed 's/^/\t/' | sort | uniq >> /tmp/submitqc/similarextensions
    echo "---" >> /tmp/submitqc/similarextensions
    echo -e "\n\t${YELLOW}There are similar named extensions in repo:${NORMAL}"
    echo "${YELLOW}$SIMILAR" | sed 's/^/\t/'
    echo -e "\t${YELLOW}Ensure there are no conflicts between $F and other extensions.${NORMAL}"
  else
    echo -e "${GREEN}Ok.${NORMAL}"
  fi

} # end checkmaintainer()

# compare ext.list to same from repo. Note/announce differences.
checklist() {

  echo -n "${BLUE}${SCRIPT}: ${F} list file looks ok? ${NORMAL}"

  # set up
  rm -f /tmp/submitqc/listfilediffs/"$F".difflist
  mkdir -p /tmp/submitqc/listfilediffs/
  ORIG="../${F}.list"
  LIST="/tmp/submitqc/listfilediffs/${F}.list.tmp"
  NEWLIST="/tmp/submitqc/listfilediffs/${F}.list.new"
  REPOLIST="/tmp/submitqc/${F}.repolist"
  LOG="/tmp/submitqc/listfilediffs/${F}.difflist"

  # make 'definitive' file list
  find -not -type d | sort | sed 's/^\.//' > ${NEWLIST}

  # if list exists, check it matches what's actually in the squashfs
  if [ ! -e "${ORIG}" ]; then
    echo -ne "\n\t${YELLOW}${F}.list missing. Creating ... ${YELLOW}"
    cp $NEWLIST $ORIG
    echo "${YELLOW}Done. ${NORMAL}"
  else
    sort < $ORIG > $LIST
    if [ "$(diff -u $LIST $NEWLIST)" ]; then
      echo -ne "\n\t${YELLOW}${F}.tcz.list does not match extension content. \
Making new ${F}.list ... ${NORMAL}"
      cp -f $NEWLIST $ORIG
      echo "${YELLOW}Done.${NORMAL}"
      echo "$F.list was rebuilt by $SCRIPT" >> $LOG
    else
      echo "${GREEN}Ok.${NORMAL}"
    fi
  fi

  # now check it against the online/repo copy
  if [ ! $INET ]; then
    echo -e "${YELLOW}$SCRIPT: $F Network/mirror down. Skipping repo .list comparison. ${NORMAL}"
  else
    echo -n "${BLUE}$SCRIPT: ${F} comparing list to mirror copy. ${NORMAL}"
    wget -O ${REPOLIST}.tmp "$REPO_URL"/"$F".list > /dev/null 2>&1
    if [ $? != 0 ]; then
      echo "${GREEN}Not on mirror. ${NORMAL}"
    else

      sort < ${REPOLIST}.tmp > $REPOLIST
      if [ "$(diff -u $LIST $REPOLIST)" ]; then
        DIFFERS=1
        diff -NBa -U 0  $REPOLIST $LIST >> $LOG
      sed -i '1,3d' $LOG
      sed -i '1i ---' $LOG
      sed -i '1i Minus is in repo list only' $LOG
      sed -i '1i Plus is in your list only' $LOG
      echo -e "\n\t${YELLOW}${F}.list differs from repo list.\n\tSee $LOG.${NORMAL}"
      else
        echo "${GREEN}Matches!${NORMAL}"
      fi

    fi
  fi

  # clean up our mess
  rm -f $REPOLIST ${REPOLIST}.tmp $LIST $NEWLIST

} # end checklist()

# list all libs included in $1 and deps, fill INCLOG
getinclibs() {

  # Substitute -KERNEL variable.
  dependent_tcz="$(echo $1 | sed "s/KERNEL/$KVER/")"

  # skip if we've already checked this file. Note if we haven't.
  echo $CHECKLIST | grep -q " $dependent_tcz" && return
    # echo -e "\nskip $dependent_tcz re-check" && return # avoid re-checking already checked
  CHECKLIST="$CHECKLIST $dependent_tcz"

  # if $dependent_tcz exists
  if [ -e $dependent_tcz ]; then
    EXT="$dependent_tcz"
  elif [ -e $REPO/$dependent_tcz ]; then
    EXT="$REPO/$dependent_tcz"
  else
    echo -e "\n\tWARNING: dependency $dependent_tcz missing - tests will be inconclusive."
    LIBTESTERROR=1
    return 1
  fi

  # list libs, append to INCLOG. First grep is remove header output from unsquashfs
  for LIB in $(unsquashfs -ls $EXT | grep "squashfs-root" | grep "\.so"); do
    echo $(basename $LIB) >> $INCLOG
  done

  # recurse deps
  [ -e ${EXT}.dep ] && \
  for INC in $(cat ${EXT}.dep); do
    getinclibs $INC
  done

}

# search local repo for missing libs, fill REPOLOG
searchlocallibs() {

  echo
  echo -e "\t${BLUE}Searching local repo for missing libs ... ${NORMAL}"

  # list local repo, lib extensions first
  # unlike find, grep use regex
  REPOFILES=$(find $REPO -maxdepth 1 -name "lib*.tcz"; find $REPO -maxdepth 1 -name "*.tcz" | grep -v '/lib.*.tcz')

  # try to find missing libs in repository
  for FILE in $REPOFILES; do

    unset FOUND
    FILELIST="$(unsquashfs -ls $FILE)"
    for REQ in $(cat $REQLOG); do
      if $(echo $FILELIST | grep -q "usr/local/lib/$REQ"); then
        echo -e "\t$REQ found in $(basename $FILE)."
        echo $(basename $FILE) >> $REPOLOG
        FOUND=1
      fi
    done # loop search for missing libs

  done # loop look for each missing lib

}

# cull deps of $1 from REPOLOG
culldeps() {

  # skip if we've already checked this file. Note if we haven't.
  echo $CHECKLIST | grep -q " $1" && return
  CHECKLIST="$CHECKLIST $1"

  # if $1 exists
  if [ -e ${1} ]; then
    EXT="${1}"
  elif [ -e $REPO/${1} ]; then
    EXT="$REPO/${1}"
  fi

  # recurse through dep file. Remove all children of $1 from REPOLOG
  [ -e ${EXT}.dep ] && \
  for REM in $(cat ${EXT}.dep); do
    sed -i "/^$REM$/d" $REPOLOG
    culldeps $REM
  done

}

# check that local dep file matches mirror. Else testing may be invalid.
checkmirror() {

  if [ -z "$INET" ]; then
    echo -en "${YELLOW}\tNo network connection - skip online dep comparison.${NORMAL}"
    return
  fi

  echo
  echo -en "\t${BLUE}Compare local $1.dep to online copy ... ${NORMAL}"

  TMPCP=/tmp/$SCRIPT/$1.dep-mirror

  wget -q --spider $MIRROR/${TCVER%%.*}.x/${ARCH}/tcz/${1}.dep
  [ $? != 0 ] && echo -e "${YELLOW}Not on mirror - skip check.${NORMAL}" && return

  wget -q -O $TMPCP $MIRROR/${TCVER%%.*}.x/${ARCH}/tcz/${1}.dep
  [ $? != 0 ] && echo -e "${YELLOW}wget error - skip check.${NORMAL}" && return

  if [ $(diff $1.dep $TMPCP) ]; then
    echo -e "${RED}Mismatch. Test likely inaccurate. diff:${NORMAL}"
    diff -u $1.dep $TMPCP | sed 's/^/\t/'
  else
    echo -e "${GREEN}matches!${NORMAL}"
  fi

  rm -f $TMPCP

}

# check binaries for dependent libs. Ensure those libs are covered by the dep file or
# included binaries
checklibs() {

  LOG="/tmp/$SCRIPT/missingdeps/$F.dep-libs"

  if [ ! "$LIBCHECK" ]; then
    echo "${YELLOW}$SCRIPT: ${F} to enable library inclusion tests, use --libs.${NORMAL}"
    echo -e "\t${YELLOW}Without lib tests, check is considered incomplete.${NORMAL}"
    echo "$SCRIPT: ${F} library inclusion disabled on commandline." >> $LOG
    return
  fi

  echo -n "${BLUE}$SCRIPT: ${F} dep file includes all necessary libraries? ${NORMAL}"
  unset LIBTESTERROR

  # so that various cat/sed calls do not err out
  touch $REPOLOG $REQLOG $INCLOG

  # list req'd libs (to temp file)
  (
  # find -type f -exec file {} \; | grep 'shared libs' | cut -f1 -d: | xargs ldd | \
    # awk '{print $1}' | sed 's/.*\///' | sort | uniq > $REQLOG
  grep 'shared object' $FILE_INFO | sed 's_: .*__g' | xargs ldd | awk '{
    c = split($1, a, "/")
    libs[a[c]] = 1
  } END {for (lib in libs) print lib}' > $REQLOG
  ) &
  rotdash $!

  # need to step out of squashfs for remainder of this check
  FSDIR="$PWD"
  cd ..

  # list included libs (to temp file)
  getinclibs ${F}

  # remove all included libs from $REQLOG
  for LIB in $([ -e "$INCLOG" ] && cat $INCLOG) $BASELIBS; do
    sed -i "/^$(basename ${LIB})$/d" $REQLOG
  done

  if [ -e "${REQLOG}" ]  && [ "$(wc -l $REQLOG | cut -f1 -d' ')" != 0 ]; then

    echo -e "\n\t${RED}Missing:${NORMAL}"
    cat $REQLOG | sed 's/^/\t/'

    echo "$F requires these libs, but they are not included:" >> $LOG
    cat $REQLOG >> $LOG

    checkmirror ${F}

    searchlocallibs

    unset CHECKLIST
    for EXT in $(cat $REPOLOG); do
      culldeps $EXT
    done

    if [ "$(cat $REPOLOG | wc -l)" != 0 ]; then

      echo
      echo -e "\t${YELLOW}Suggested additions to dep file:${NORMAL}"
      cat $REPOLOG | sort | uniq > $REQLOG
      cat $REQLOG | sed 's/^/\t/'

      echo -e "\nSuggested additions to $F.dep:" >> $LOG
      cat $REQLOG >> $LOG
      echo >> $LOG

      if [ -z "$NOFIX" ]; then
        cat $REQLOG >> ${F}.dep
        echo -e "\t${YELLOW}These were added to $PWD/${F}.dep.${NORMAL}"
        echo "These were added to ${F}.dep:" >> $LOG
        cat $REQLOG >> $LOG
      else
        echo -e "\t${YELLOW}Omit the --no-fix flag to append these to ${F}.dep${NORMAL}"
      fi
    else
      echo -e "\t${YELLOW}No additions from local repo suggested.${NORMAL}"
    fi

    RET=1

  else
    echo -e "${GREEN}Ok!${NORMAL}"
    RET=0
  fi

  [ $LIBTESTERROR ] && echo -e "\n\tWARNING: error during tests - inconclusive"
  rm -f $REPOLOG $REQLOG $INCLOG

  # return to squashfs root for remainder of checks
  cd $FSDIR

  return $RET

}

checkremotedep() {

  if [ ! "$INET" ]; then
    echo -e "${YELLOW}$SCRIPT: $F Network/mirror down. Skipping repo .dep comparison.${NORMAL}"
    return
  fi

  echo -n "${BLUE}$SCRIPT: $F dep file compared to repository copy? ${NORMAL}"

  DEPLIST="$(find -maxdepth 1 -name ${F}.dep)"
  REPODEP=
  LOG="/tmp/submitqc/missingdeps/${F}.dep"
  DIFFLOG=$LOG.diff

  # see if there is a dep file on the server

  REPODEP=${REPO_URL}/${F}.dep
  wget -q --spider ${REPO_URL}/${F}.dep || REPODEP=

  if [ ! $REPODEP ]; then
    echo "${GREEN}No dep file in repo - done.${NORMAL}"
    return
  fi

  if [ ! $DEPLIST ]; then
    echo -e "\n\t${YELLOW}No $F.dep, but exists on mirror. Check manually.${NORMAL}"
    echo "$F.dep not found, but exists on mirror. Reconfirm." >> /tmp/submitqc/confirmnodeps
    return
  fi

  # Last case: get remote deplist, diff
  wget -q $REPODEP -O /tmp/submitqc/missingdeps/$F.dep.remote \
  && REPODEP=/tmp/submitqc/missingdeps/$F.dep.remote

  if [ "$(diff -u $REPODEP $DEPLIST)" ]; then
    diff -u $REPODEP $DEPLIST > $DIFFLOG
    echo -e "\t${YELLOW}There were differences between the remote and local dep lists."
    echo -e "\t${YELLOW}See $DIFFLOG.${NORMAL}"
  fi

  rm -f $REPODEP

  echo -e "\t${GREEN}Ok.${NORMAL}"

}

checkdeps() {

  echo -n "${BLUE}$SCRIPT: $F dependencies exist? ${NORMAL}"

  DEPLIST="$(find -maxdepth 1 -name ${F}.dep)"
  LOG="/tmp/submitqc/missingdeps/${F}.dep"

  if [ ! "$DEPLIST" ]; then
    echo "${GREEN}No dep file. Ok.${NORMAL}"
    return
  fi

  # do the extensions listed in the dep file end in .tcz? 20151005
  COUNT=0
  for DEP in $(cat ${F}.dep); do
    if [ "${DEP##*.}" != "tcz" ]; then
      echo -en "\n\t${RED}entry $DEP is invalid - .tcz extension missing.${NORMAL}"
      echo "Entry $DEP is invalid - .tcz extension missing." >> $LOG
    fi
    let COUNT=$COUNT+1
  done

  if [ $COUNT != "$(wc -l ${F}.dep | cut -f1 -d' ')" ]; then
    echo -en "\n\t${RED}${F}.dep structure invalid - blank lines or more than one file per line.${NORMAL}"
    echo "${F}.dep structure is invalid - extra lines, or not one dep per line." >> $LOG
  fi

  if [ -e "${LOG}" ]; then
    if [ -z "$NOFIX" ]; then
      echo -en "\n\t${YELLOW}Repairing .dep file ... ${NORMAL}"

      # for each line that does -not- end in .tcz, add it.
      for DEP in $(cat ${F}.dep); do
        if [ "${DEP##*.}" != "tcz" ]; then
          DEP="${DEP}.tcz"
        fi
        echo $DEP >> /tmp/submitqc/missingdeps/${F}.dep-new
      done
      mv -f /tmp/submitqc/missingdeps/${F}.dep-new ${F}.dep
      [ $? != 0 ] && echo "${RED}Error replacing ${F}.dep with /tmp/submitqc/missingdeps/${F}.dep-new. Halting.${NORMAL}" && exit 1
      echo -en "\n\t${GREEN}Done!${NORMAL}"
      echo "These missing filename extensions were appended." >> $LOG
    else
      echo -en "\n\t${YELLOW}Omit the --no-fix flag to repair these errors${NORMAL}"
    fi
  fi

  # does this dep file use the KERNEL variable as needed?
  if [ "$(grep -qe '-.*-tinycore' ${F}.dep)" ]; then
    echo -en "\n\t${YELLOW}Need to use KERNEL variable, not version number. Fixing ...${NORMAL}"
    sed -i 's/\(.*-\)[0-9].*/\1KERNEL.tcz/' ${F}.dep
    echo "${YELLOW} Done.${NORMAL}"
    echo "${F}.dep should use KERNEL variable instead of ver number. Fixed.${NORMAL}" >> $LOG
  fi

  [ -z $INET ] && echo -en "${YELLOW}\n\tNetwork/mirror down - remote checking disabled.${NORMAL}"
  [ $KERNELFORCE ] && echo -en "${YELLOW}\n\tkernel forced to $KVER on commandline${NORMAL}"

  # check that every dependency is either (1) on mirror or (2) in local directory
  echo ""
  for DEP in $(cat "${F}.dep"); do

    # make KERNEL variable substitution
    DEP="$(echo $DEP | sed "s/KERNEL/$KVER/")"

    echo -en "\t${BLUE}$DEP: ${NORMAL}"

    # check if dependency exists on server or locally
    LOCAL=
    [ -e "$DEP" ] || [ -e "$REPO/$DEP" ] && LOCAL=1
    REMOTE=
    [ $INET ] && wget -q --spider ${REPO_URL}/$DEP && REMOTE=1

    # echo feedback
    if [ $INET ]; then # both or local

      if [ $REMOTE ]; then
        echo "${GREEN}found in repository.${NORMAL}"
      elif [ $LOCAL ]; then
        echo "${YELLOW}found locally. Submit with extension.${NORMAL}"
      else
        echo "${RED}Not found.${NORMAL}"
        echo "$DEP not local, not remote" >> $LOG
      fi

    else # no networking. It's either here or it isn't.
      if [ "$LOCAL" ]; then
        echo "${YELLOW}$DEP found locally. Submit with extension.${NORMAL}"
      else
        echo "${YELLOW}$DEP assumed to be in network repository.${NORMAL}"
        echo "$DEP not local, remote search disabled." >> $LOG
      fi
    fi

  done # end checking Kernel Module deps

  # summary statement
  if [ -e $LOG ] && [ "$(wc -l $LOG | awk '{print $1}')" != 0 ]; then
    echo -e "\t${RED}There are warnings or errors. See $LOG${NORMAL}"
  else
    echo -e "\t${GREEN}Done.${NORMAL}"
    rm -f $LOG
  fi

} # end checkdeps()

checkinfo() {

  echo -n "${BLUE}$SCRIPT: $F info file structure ok? ${NORMAL}"

  if [ ! -f "$F".info ]; then
    echo -e "\n\t${RED}${F}.info file not found. Do NOT submit without it.${NORMAL}"

    if wget --spider -q "${REPO_URL}/$F.info" &> /dev/null; then
      wget -q "${REPO_URL}/$F.info"
      echo -e "\t${YELLOW}Found $F.info in repo. Fetching it.\n\tModify the $F.info to include any updates."
      echo "$F" >> /tmp/submitqc/notmodifiedinfofile
    else
      echo "$F" >> /tmp/submitqc/noinfofile
    fi

    return
  fi

  I="$F".info
  TITLELINE="$(grep -m1 -G "^Title" "$I")"
  TITLE=$(echo "$TITLELINE" | awk '{print $2}')
  if [ "$TITLE" != "$F" ]; then
    [ -z $ERR ] && ERR=1 && echo ""
    echo -ne "\n\t${YELLOW}$SCRIPT: $I Title field ($TITLE) is missing or incorrect. Fixing. ${NORMAL}"
    if [ "$TITLE" ]; then
      [ "$(echo "$TITLELINE" | grep "TESTING")" ] && TESTING=" TESTING"
      sed -i "s/^Title.*$/Title:\t\t${F}${TESTING}/" ${I} # edit existing line
    else
      sed -i "1iTitle:\t\t${F}\\" ${I} # append missing title to top
    fi
    echo "${YELLOW}Done.${NORMAL}"
    echo "$I title field invalid, fixed." >> /tmp/submitqc/wronginfofile
  fi

  SIZE=$(du -h "$F" | cut -f 1)
  SIZE2=$(busybox du -h "$F" | cut -f 1)
  INFOSIZE="$(cat $I | grep "Size" | awk '{print $2}')"
  if [ "$INFOSIZE" != "$SIZE" ] && [ "$INFOSIZE" != "$SIZE2" ]; then
    [ -z $ERR ] && ERR=1 && echo ""
    echo -en "\n\t${YELLOW}Size field ($INFOSIZE) does not match du output ($SIZE). Fixing. ${NORMAL}"
    if [ "$(cat $I | grep Size)" ]; then
      sed -i "s/^Size.*/Size:\t\t$SIZE/" ${I} # edit existing line
    else
      sed -i "6iSize:\t\t$SIZE" ${I} # insert
    fi
    echo "${YELLOW}Done.${NORMAL}"
    echo "$I size field invalid, fixed." >> /tmp/submitqc/wronginfofile
  fi

  for FIELD in Change-log Comments Description Version Author Original-site \
  Copying-policy "Extension[-_]by" "Tags:" Current; do
    if [ -z "$(cat "$I" | grep "$FIELD" | awk '{print $2}')" ]; then
      [ -z $ERR ] && ERR=1 && echo ""
      echo -e "\t${RED}$FIELD missing or invalid. Fix before submitting.${NORMAL}"
      echo "$I: $FIELD field is missing or invalid." >> /tmp/submitqc/wronginfofile
    fi
  done

  if [ "$(file $I | grep CRLF)" ]; then
    ERR=1
    echo -ne "\n\t${YELLOW}$SCRIPT: $I uses Windows-like CRLF terminators. Fixing. ${NORMAL}"
    dos2unix -u $I
    echo "$I uses Windows-like CRLF terminators. Fixed." >> /tmp/submitqc/wronginfofile
    echo "${YELLOW}Done.${NORMAL}"
  fi

  [ -z $ERR ] && echo "${GREEN}Ok.${NORMAL}"

} # end checkinfo()

# check md5sum.txt
checkmd5sums() {

  echo -n "${BLUE}$SCRIPT: $F checking md5.txt. ${NORMAL}"
  MD5=${F}.md5.txt
  if [ ! -f "$MD5" ] || [ "$(cat ${MD5})" != "$(md5sum ${F})" ]; then
    echo -en "\n\t${YELLOW}${F} md5 mismatch - creating new ${MD5} ... ${NORMAL}"
    md5sum ${F} > ${MD5}
    echo ${F} >> /tmp/submitqc/wrongmd5
    echo "${YELLOW}Done.${NORMAL}"
  else
    echo "${GREEN}Ok.${NORMAL}"
  fi

}

# make zsync file
makezsync() {

  LOG=/tmp/submitqc/zsync.$F
  rm -f $LOG

# totally fine now 20230828
#   if [ "$ARCH" = "armv7" ]; then
#     echo "${YELLOW}$SCRIPT: skipping zsync creation - zsync support uncertain on armv7. Please \
# submit zsync availability (script patches?) to maintainer."
#     echo "$SCRIPT: $F.zsync not created; unknown whether armv7 has zsync support. Please report." \
#       > $LOG
#     return
#   fi

  echo -n "${BLUE}$SCRIPT: $F creating new $F.zsync ${NORMAL}"
  rm -f ${F}.zsync
  zsyncmake -u ${F} ${F}
  if [ $? != 0 ]; then
    echo -e "\n\t${RED}$SCRIPT: unknown error creating $F.zsync. Re-make manually.${NORMAL}"
    echo "${RED}Do NOT submit without zsync file.${NORMAL}"
    echo "$SCRIPT: unknown error creating $F.zsync. Re-make manually." > $LOG
  else
    echo "${GREEN}Done.${NORMAL}"
  fi

}

# Re-squash SQUASHDIR, use new file to replace F
rebuild() {

  echo -n "${BLUE}$SCRIPT: make squashfs with changes ... ${NORMAL}"

  # original:
  #if [ "$BADPERM" == "1" ]; then
  #for I in `find "$F".123456789/ -type d`; do stat -c '%a' "$I" | grep 755 >/dev/null || \
  #stat -c '%a' "$I" | grep 775 >/dev/null || stat -c '%a' "$I" | grep 2755 >/dev/null || \
  #stat -c '%a' "$I" | grep 2775 >/dev/null || chmod 755 "$I" ; done
  #fi

  # make new/fixed extension
  sudo rm -f "$F".new # jic
  sudo mksquashfs ${SQUASHDIR} "$F".new -b "$BLOCKSIZE" -noappend > /dev/null # noappend suggested by robc
  [ $? != 0 ] && echo "${RED}$SCRIPT: there was an error in mksquashfs. Halting." && exit 1
  sudo chmod 664 ${F}.new
  sudo chown tc:staff ${F}.new
  mv "$F".new "$F"

  # make list and md5
  md5sum ${F} > ${F}.md5.txt
  find ${SQUASHDIR} -not -type d | sed "s/${SQUASHDIR}//" > ${F}.list

  echo "${GREEN}Done. ${F} + ${F}.md5.txt updated.${NORMAL}"

} # end rebuild()

# look for date, version, build-deps, build-args
checkbuilddep() {

  echo -n "${BLUE}$SCRIPT: $F.build-dep or build-dep included?${NORMAL}"

  if [ ! -e "$F.build-dep" ] && [ ! -e "build-dep" ]; then
    echo -e "\n\t${GREEN}Not found, but it is suggested/requested.${NORMAL}"
    return
  fi

  echo "${GREEN}Yes - thanks!${NORMAL}"

}

# look tgz that contains source & script
checktgz() {

  echo -n "${BLUE}$SCRIPT: $F.tgz or $F.tar.gz included?${NORMAL}"

  if [ -f "$F.tar.gz" ]; then
    if [ -f "$F.tgz" ]; then
      echo "${YELLOW}$F.tar.gz and $F.tgz both found. Using $F.tgz."
    else
      echo "${YELLOW}Found only $F.tar.gz. Changing it to $F.tgz."
      mv "$F.tar.gz" "$F.tgz"
    fi
  fi

  if [ ! -e "$F.tgz" ]; then
    echo -e "\n\t${GREEN}Not found, but it is suggested/requested.${NORMAL}"
    return
  fi

  # check file type
  if ! tar tf "$F.tgz" &> /dev/null && ! gzip -t "$F.tgz" &> /dev/null; then
    echo "${RED}Found errors in testing the integrity of $F.tgz. Please repack it."
    echo "Found errors in testing the integrity of $F.tgz. Please repack it." > /tmp/submitqc/badtgz
    return
  fi

  # check file content
  if [ "$(tar tf "$F.tgz" | wc -l)" -eq 0 ]; then
    echo "${RED}No files found in $F.tgz. Please check your source archive before submission."
    echo "No files found in $F.tgz. Please check your source archive before submission." > /tmp/submitqc/emptytgz
  fi

  echo "${GREEN}Yes - thanks!${NORMAL}"

}

prepareinfo() {
  # added by polikuo
  # the purpose is to store the info for an easier access
  # because the "find" command takes up a lot of time to traverse
  # and the output is reusable
  # cleanup first
  :> $AWK_CACHE
  :> $FILE_PERM
  :> $FILE_INFO
  # guard the command length with awk
  # so 'ls' & 'file' won't blow up if the list gets too long
  # buff = ' really long command', with a space at the start
  find | awk -v cache="$AWK_CACHE" '{
    if(/ /) {
      print "Warning, filename: [" $0 "] contains empty space, skipped !" >> "/tmp/submitqc/filename-with-space"
      system("file \"" $0 "\" >> /tmp/submitqc/filename-with-space")
    } else {
      if(length(buff " " $0) > 130000) {
        system("/bin/busybox ls -ld" buff " >> " cache)
        buff = ""
      }
      buff = buff " " $0
    }
  } END {if(buff) system("/bin/busybox ls -ld" buff " >> " cache)}'
  # we only need a few sections from the generated 'ls -l' information
  # valid linux file types: '-', d, l, b, c, n, p, s
  awk '/^[-dbcnps]/{print $1, $3, $4, $NF}' $AWK_CACHE > $FILE_PERM
  # only link files has extra column
  awk '/^l/{print $1, $3, $4, $(NF-2)}' $AWK_CACHE >> $FILE_PERM
  # store "file" info
  awk -v cache="$FILE_INFO" '{
    if(length(buff " " $0) > 130000) {
      system("file" buff " >> " cache)
      buff = ""
    }
    buff = buff " " $NF
  } END {if(buff) system("file" buff " >> " cache)}' $FILE_PERM
} # end prepareinfo()


# Check for redundant dependencies.
checkdepfamilies() {
  echo -n "${BLUE}$SCRIPT: $F contains redundant dependencies (extension families) in .dep file ? ${NORMAL}"

  # Return if no .dep file.
  if [ ! -f "$F.dep" ]; then
    echo "${GREEN}No .dep file. Ok.${NORMAL}"
    return
  fi

  if [ ! "$INET" ]; then
    echo -e "\n${YELLOW}$SCRIPT: Network/mirror down.\n${NORMAL}"
    return
  fi


  RESOLVED_DEPS="$(awk -v TCZ="$F.dep" -v KERNELVER="$KVER" '
  BEGIN {
    RS = ""
    FS = "\n"
  }

  # Processes dep.db.
  {
    tcz = $1
    sub("-" KERNELVER, "-KERNEL", tcz)
    for (i = 2; i <= NF; i++) {
      dep = $i
      sub("-" KERNELVER, "-KERNEL", dep)
      db[tcz] = (dep " " db[tcz])
    }
  }

  END {
    RS = "\n"
    c = 0

    while ((getline dep < TCZ) > 0) {
      gsub(/ |\n/, "", dep)
      if (!dep) continue

      sub("-" KERNELVER, "-KERNEL", dep)
      required[dep] = 1
      queue[dep] = 0
      c++
    }
    close(TCZ)

    while (length(queue)) {
      for (depname in queue)
        break

      delete queue[depname]

      split(db[depname], subdeps, " ")
      for (subdepindex in subdeps) {
        subdepname = subdeps[subdepindex]

        gsub(/ |\n/, "", subdepname)
        if (!subdepname) continue
        if (subdepname in provided) continue

        queue[subdepname] = 1
        provided[subdepname] = 1
      }
    }

    for (dep in required)
      if (!(dep in provided))
        list[dep] = 1
    for (dep in list)
      print dep
  }' < /tmp/submitqc/.dep.db)"


  # If resolved and removed redundancy, replace .dep file.
  # Otherwise, just return.
  OLD_DEPS_COUNT="$(tr -d " " < "$F.dep" | tr -s "\n" | wc -l)"
  NEW_DEPS_COUNT="$(echo "$RESOLVED_DEPS" | wc -l)"
  if [ "$NEW_DEPS_COUNT" -lt "$OLD_DEPS_COUNT" ]; then
    echo -e "\n${YELLOW}Originally found ${GREEN}$OLD_DEPS_COUNT${YELLOW} deps"
    echo -e "${YELLOW}Now reduced to ${GREEN}$NEW_DEPS_COUNT${YELLOW}."
    echo -e "${YELLOW}Backup old dependency list to ${GREEN}$F.dep.bak${YELLOW}."

    if [ -z "$NOFIX" ]; then
      mv "$F.dep" "$F.dep.bak"
      echo "$RESOLVED_DEPS" > "$F.dep"
    else
      echo "${YELLOW}--no-fix enabled. Please remove the argument to remove redundant dependencies."
    fi

    # Log reporting.
    {
      echo "Reduced dependencies from:"
      cat "$F.dep.bak"
      echo "to:"
      echo "$RESOLVED_DEPS"
    }  > /tmp/submitqc/redundantdependencies
  else
    echo "${GREEN}No redundant dependencies found in $F.dep file."
  fi
  echo "${GREEN}Ok.${NORMAL}"
}


####################
#########################
# MAIN STUFF BEGINS
#########################
####################

trap cleanonsignal SIGHUP SIGINT SIGQUIT SIGTERM SIGSTOP SIGABRT

announce # intro text

# self-package! =D
if [ $PACKAGING ]; then
  selfpackage
  exit
fi

if [ -z "$NOLOAD" ]; then
  loadextensions # load coreutils & the like
fi
cleanuplogs # remove old logs, create new log dir at /tmp/submitqc
checknetwork # connect to mirror if possible

######################
# TESTING LOOP
######################

for F in $TCZLIST; do

  echo ""
  echo "${BLUE}$SCRIPT: $F checks begin ===== ${NORMAL}"

  # ensure squashfs has something in it
  checkempty || {
    echo "${RED}$SCRIPT: $F testing aborted. Fix squashfs and re-test.${NORMAL}"
    continue
  }

  # allocate a folder for unsquashing & checking the extension
  BASENAME="$(basename "$F" .tcz)"
  SQUASHDIR="${BASENAME}.submitqc.$(date +%s | md5sum | head -c4)"

  TEMPLIST="$SQUASHDIR"

  # in particular, dep check/fix should be before lib checking (in loop below)
  checkmaintainer # check maintainer, look for similar extension names
  checkremotedep # check exists, check against repo copy
  checkdeps # check each dependency exists (NOT recursive)

  checkmount # try to mount. Returns 0 on success, 1 on failure

  if [ $? = 0 ]; then

    CHANGES= # set to 1 when the script changes some details

    checkblock # ensure F was made with expected blocksize

    #####
    # this section runs tests from within the squashfs root directory
    #####

      (
      echo -n "${BLUE}$SCRIPT: $F unsquashing for further tests ... ${NORMAL}"
      sudo unsquashfs -d ${SQUASHDIR} ${F} > /dev/null # unsquash to check
      echo "${GREEN}Done.${NORMAL}"
      ) &
      rotdash $!

      cd ${SQUASHDIR} # do all the checks from here

      # valid squashfs? 1 and only 1?
      checkappend || {
        echo "${RED}$SCRIPT: $F testing aborted. Fix squashfs and re-test.${NORMAL}"
        cd "$RUNDIR"
        sudo rm -rf ${SQUASHDIR}
        TEMPLIST=
        continue
      }

      prepareinfo # store the output of "find" and "ls", only need to find once
      checkstartup # check/fix tce.installed (775, root:staff, one script of same name as ext)
      checkcopyright # look for COPYING or other doc at usr/local/share/doc/$F
      checkfileperms # check/fix directory & file permissions. Skipped if --no-fix.
      checkstripping # ensure binaries/libraries have been stripped. Strip on --strip.
      checklib64 # Warn elfs linked to /lib64/
      checklist # check list file against squashfs and repo

      checklibs # check what binary dependencies the included binaries contain ...

      cd "$RUNDIR" # return to rundir

    #####
    # returned to rundir
    #####

    [ "$CHANGES" ] && rebuild # commit changes to new tcz file

    checkinfo # check fields exist, etc.
    checkdepfamilies
    checkmd5sums

    (
    echo -n "${BLUE}${SCRIPT}: $F squash tree checks complete. Cleaning up ... ${NORMAL}"
    sudo rm -rf ${SQUASHDIR}
    echo "${GREEN}Done.${NORMAL}"
    TEMPLIST=
    ) &
    rotdash $!

    makezsync # create new zsync file, jic

    checkbuilddep # check for build-dep text file
    checktgz # check for .tgz (source & script) file

    # Permissions/ownership cleanup
    echo -n "${BLUE}$SCRIPT: $F: setting ownership & permissions of ${F}* ... ${NORMAL}"
    find -maxdepth 1 -type f -name "${F}.tcz*" -exec sudo chown tc:staff {} \;
    find -maxdepth 1 -type f -name "${F}.tcz*" -exec sudo chmod 664 {} \;
    echo "${GREEN}Ok!${NORMAL}"

  fi # end if [ it was mount-able and test-able ]

  echo "${BLUE}$SCRIPT: $F checks end ===== ${NORMAL}"

done # end loop all extensions

# remove temporary files
rm -f $FILE_INFO $FILE_PERM $AWK_CACHE

#############
# REPORTING
#############

# list all the log files with content
cd /tmp/submitqc
LOGLIST="$(find -type f -exec ls -s {} \; | sed '/^0/d' | sed 's/\.\///' | \
  sed '/.info.lst/d' | sed '/.dep.db/d' | awk '{print $2}'; \
  [ -e "missingdeps" ] && find missingdeps -not -type d;
  [ -e "listfilediffs" ] && find listfilediffs -not -type d;)"

# report!
echo ""
echo ""
if [ "$LOGLIST" ] && [ "$(cat $LOGLIST)" ]; then
  echo "${RED}${SCRIPT}: There are warnings or errors for your extensions. See:${NORMAL}"
  echo "$LOGLIST" | sed 's/^/\t\t\/tmp\/submitqc\//' | sort | uniq
  echo -e "${RED}\tSome errors may have been corrected - see logs and above.${NORMAL}"
  echo -e "${RED}\tFix errors and run $SCRIPT again before submitting.${NORMAL}"
  echo -e "${RED}\tLog files will be destroyed the next time $SCRIPT is run.$NORMAL"
  echo -e "${RED}\tWithout warnings or errors, this message will go away.${NORMAL}"
else
  echo "${BLUE}${SCRIPT}: ${GREEN}All extensions passed! Ready for submission.${NORMAL}"
fi
